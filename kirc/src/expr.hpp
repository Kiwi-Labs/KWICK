#ifndef KIWI_EXPR_HPP
#define KIWI_EXPR_HPP

#include "value.hpp"
#include "type.hpp"
#include "utils.hpp"

namespace KIR
{
	class Expression: public Value, public Stringable, public Cloneable
	{
	public:
		virtual ~Expression() {}
		virtual Expression* clone() = 0;
		virtual bool validate() = 0;
	};

	class ErrorCascadeExpression: public Expression
	{
	public:
		std::string error;
		ErrorCascadeExpression(std::string _error) : error(_error) {}
	};

	class IntegerLiteralExpression: public Expression
	{
		IntegerType* type; // The integer type - necessary because "IntegerType" represents a whole range of different datatypes.
		long long int val; // The expression's value, known at compile time.
	public:
		IntegerLiteralExpression(long long int _val, IntegerFormat _format) : val(_val)
		{
			type = new IntegerType(_format);
		}
		~IntegerLiteralExpression()
		{
			delete type;
		}
		Type* getType() { return type; } // Get the type - but since it might be kept elsewhere, clone it.
		IntegerLiteralExpression* clone()
		{
			return new IntegerLiteralExpression(val, type->format);
		}
		bool validate() { return true; } // STUB! Final validate function will ensure value adheres to given format.
		std::string toString()
		{
			return (std::stringstream() << val << " : " << type->toString()).str();
		}
	};

	class FloatLiteralExpression: public Expression
	{
		FloatType* type; // The float type - necessary because "FloatType" represents a range of different floating point formats.
		long double val; // The expression's value, known at compile time.
	public:
		FloatLiteralExpression(long double _val, FloatFormat _format) : val(_val)
		{
			type = new FloatType(_format);
		}
		~FloatLiteralExpression()
		{
			delete type;
		}
		Type* getType() { return type; } // Get the type - but since it might be kept elsewhere, clone it.
		FloatLiteralExpression* clone()
		{
			return new FloatLiteralExpression(val, type->format);
		}
		bool validate() { return true; } // STUB! Final validate function will ensure value adheres to given format.
		std::string toString()
		{
			return (std::stringstream() << val << " : " << type->toString()).str();
		}
	};

	class TupleExpression: public Expression
	{
		std::vector<Expression*> exprs; // Vector of stored expressions.
		TupleType* type;
	public:
		TupleExpression(std::initializer_list<Expression*> _exprs) : exprs(_exprs)
		{
			std::vector<Type*> types;
			for (std::vector<Expression*>::iterator it = exprs.begin(); it < exprs.end(); it++)
			{
				types.push_back((*it)->getType());
			}
			type = new TupleType(types);
		}
		TupleExpression(std::vector<Expression*> _exprs) : exprs(_exprs)
		{
			std::vector<Type*> types;
			for (std::vector<Expression*>::iterator it = exprs.begin(); it < exprs.end(); it++)
			{
				types.push_back((*it)->getType());
			}
			type = new TupleType(types);
		}
		~TupleExpression()
		{
			for (auto it = exprs.begin(); it < exprs.end(); it++)
			{
				delete (*it);
			}
			exprs.clear();
		}
		Type* getType()
		{
			return type;
		}
		TupleExpression* clone()
		{
			std::vector<Expression*> nexprs;
			for (auto it = exprs.begin(); it < exprs.end(); it++)
				nexprs.push_back((*it)->clone());
			return new TupleExpression(nexprs);
		}
		bool validate() { return true; } // STUB! What the hell can be validated here? Type is autogenerated, guaranteed correct. Just return true and be done w/ it.
		std::string toString()
		{
			std::stringstream out;
			if (exprs.size() == 0) return "()";
			out << "(" << exprs[0]->toString();
			for (auto it = exprs.begin(); it < exprs.end(); it++)
			{
				out << ", " << (*it)->toString();
			}
			out << ")";
			return out.str();
		}
	};

	class FunctionCallExpression: public Expression
	{
		Function* func; // The function being called.
		TupleExpression* args; // The expressions used as arguments to the function.
	public:
		FunctionCallExpression(Function* _func, TupleExpression* _args) : func(_func), args(_args) {}
		~FunctionCallExpression()
		{
			delete func;
			delete args;
		}
		Type* getType() { return func->getType()->getRets(); }
		bool validate()
		{
			return *(args->getType()) == *(func->getType()->getArgs()); // Ensure type of arguments matches expected argument type.
		}
		std::string toString()
		{
			return (std::stringstream() << func->getIdentifier() << args->toString() << " : " << func->getType()->getRets()->toString()).str();
		}
	};

	class Accessible;
	class AccessExpression: public Expression
	{
		SymbolIdentifier id;
		Expression* lhs;
		Accessible* getLHSDefinition();
	public:
		AccessExpression(Expression* _lhs, SymbolIdentifier _id) : lhs(_lhs), id(_id) {}
		~AccessExpression()
		{
			delete lhs;
		}
		Type* getType();
		bool validate();
		std::string toString()
		{
			return (std::stringstream() << "(" << lhs->toString() << ")." << id).str();
		}
	};

	class LoadExpression: public Expression
	{
		Binding* bd;
	public:
		LoadExpression(Binding* _bd) : bd(_bd) {}
		Type* getType();
		bool validate()
		{
			return bd != NULL;
		}
		std::string toString();
	};
}

#endif